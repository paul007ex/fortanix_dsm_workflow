#!/usr/bin/python
"""
Fortanix Secure Communication Script
====================================

Description:
    This script demonstrates secure communication workflows using Fortanix DSM. 
    It supports AES encryption, RSA encryption, and a combined AES-RSA workflow to ensure 
    confidentiality, integrity, and authenticity of messages.

Usage:
    python fortanix_secure_comm_v4.py --api-key <API_KEY> --workflow <aes|rsa|combined> --message <message>

Author:
    Paul Volosen
    paul007ex@mgmail.com

Version:
    1.0.0

Date:
    2026-01-18

License:
    This script is licensed under the MIT License.
    See the LICENSE file for details.

Dependencies:
    - argparse (Standard Library)
    - Fortanix DSM SDK (Install via pip: `pip install fortanix-dsm-sdk`)
    - Python 3.8 or higher

Notes:
    - Ensure that Fortanix DSM is properly configured with API access.
    - Verify that the required keys are created in DSM prior to execution.

Key Features:
1. Key Management in DSM:
   - Creation and retrieval of cryptographic keys (AES and RSA) securely stored in the DSM.
   - Secure handling of symmetric (AES) and asymmetric (RSA) keys.

2. Data Security:
   - AES encryption for message confidentiality.
   - RSA encryption for securely transmitting the AES key.
   - Digital signatures for message authenticity and integrity.

3. Protocol Workflow:
   - Sender encrypts the message using AES and encrypts the AES key with RSA.
   - The message is signed using the sender's private RSA key.
   - Receiver decrypts the AES key using RSA and the message using AES.
   - Receiver verifies the signature using the sender's public RSA key.

Workflow Details:
1. Initialization:
   - Parse command-line arguments for DSM API configuration.
   - Authenticate with the DSM and initialize cryptographic clients.
   - Create or retrieve RSA and AES keys from DSM.

2. Sender Workflow:
   - Encrypt the plaintext message using AES.
   - Encrypt the AES key using the receiver's RSA public key.
   - Sign the message using the sender's RSA private key.

3. Receiver Workflow:
   - Decrypt the AES key using the receiver's RSA private key.
   - Decrypt the ciphertext using the AES key.
   - Verify the message's signature using the sender's RSA public key.

4. Validation:
   - Ensure the decrypted message matches the original plaintext.
   - Confirm the signature verification result.

Use Cases:
1. Basic AES Workflow:
   - Encrypt and decrypt a message using AES.

2. Basic RSA Workflow:
   - Encrypt a message using RSA and verify its integrity with a digital signature.

3. Advanced AES-RSA Workflow:
   - Combine AES for message encryption and RSA for key exchange.

Protocol Flow (Example: Advanced AES-RSA Workflow):
+------------------+               +-------------------+
|   Sender (John)  |               |  Receiver (Priya) |
+------------------+               +-------------------+
            |                                |
[Retrieve RSA Key]                  [Retrieve RSA Key]
[Retrieve AES Key]                               |
            v                                v
  [Encrypt Message]  ----------------->  [Decrypt AES Key]
  [Encrypt AES Key]                       [Decrypt Message]
  [Sign Message]                         [Verify Signature]
            |                                |
            v                                v
["Hello Priya"(AES Key)](John's RSA Public Key)   ["Hello Priya"(AES Key)]
 + [Digest("Hello Priya")](Signed with John's RSA Private Key)

Encapsulation Example:
Step 1: Message encrypted with AES key:
["Hello Priya"(AES Key)]

Step 2: AES key encrypted with RSA:
[["Hello Priya"(AES Key)](John's RSA Public Key)]

Step 3: Signed Message:
[[["Hello Priya"(AES Key)](John's RSA Public Key)] + [Digest("Hello Priya")](Signed with John's RSA Private Key)]

Usage:
```bash
python fortanix_secure_comm_v4.py --api-key <Base64-Encoded-API-Key> --api-endpoint <DSM-Endpoint> --workflow <rsa|aes|combined> --debug
```

Modules Used:
- `sdkms`: Fortanix SDK for DSM interactions.
- `argparse`: Parsing command-line arguments.
- `base64`: Encoding and decoding keys.
- `termcolor`: For color-coded logging.
"""

from __future__ import print_function
import argparse
import base64
import sdkms
from sdkms.v1.models.cipher_mode import CipherMode
from sdkms.v1.models.object_type import ObjectType
from sdkms.v1.models.digest_algorithm import DigestAlgorithm
from termcolor import colored

# Default configuration
DEFAULT_API_ENDPOINT = "https://apps.smartkey.io"
DEBUG = False

# Global variables
ca_certificate = None
api_instances = {}

# Utility Class for Logging
class Logger:
    @staticmethod
    def log(message, level="INFO"):
        color_map = {
            "INFO": "green",
            "WARNING": "yellow",
            "ERROR": "red",
        }
        print(f"[{level}] {colored(message, color_map.get(level.upper(), 'white'))}")

# DSM Client Initialization
class DSMClient:
    @staticmethod
    def initialize():
        """Initialize the Fortanix DSM client."""
        global api_instances
        api_key = base64.b64decode(cl_args.api_key).decode('ascii')
        username, password = api_key.split(':')

        config = sdkms.v1.configuration.Configuration()
        config.username = username
        config.password = password
        config.verify_ssl = cl_args.verify_ssl
        config.host = cl_args.api_endpoint
        
        if ca_certificate:
            config.ssl_ca_cert = ca_certificate

        client = sdkms.v1.ApiClient(configuration=config)
        auth_instance = sdkms.v1.AuthenticationApi(api_client=client)
        auth = auth_instance.authorize()
        
        config.api_key['Authorization'] = auth.access_token
        config.api_key_prefix['Authorization'] = 'Bearer'

        api_instances = {
            'auth': auth_instance,
            'crypto': sdkms.v1.EncryptionAndDecryptionApi(api_client=client),
            'signverify': sdkms.v1.SignAndVerifyApi(api_client=client),
            'digest': sdkms.v1.DigestApi(api_client=client),
            'sobjects': sdkms.v1.SecurityObjectsApi(api_client=client)
        }
        Logger.log("DSM client initialized successfully.")

    @staticmethod
    def get_instance(name):
        return api_instances[name]


# CryptoManager
class CryptoManager:
    """
    CryptoManager
    ==============

    This class provides utility functions to manage cryptographic operations 
    using the Fortanix DSM. It includes methods for key management, encryption, 
    decryption, signing, and signature verification.

    Methods:
        - create_or_retrieve_key: Creates or retrieves cryptographic keys.
        - encrypt: Encrypts plaintext using the DSM.
        - decrypt: Decrypts ciphertext using the DSM.
        - sign: Signs data using the DSM.
        - verify: Verifies a signature using the DSM.

    Dependencies:
        - Fortanix DSM SDK (sdkms)
        - Logger (custom logging utility)

    """

    @staticmethod
    def create_or_retrieve_key(name, key_type, size):
        """
        Create or Retrieve a Cryptographic Key
        --------------------------------------

        This method checks if a key with the given name exists in the DSM. If found,
        it retrieves the key. Otherwise, it creates a new key with the specified type
        and size.

        Parameters:
            name (str): Name of the key to retrieve or create.
            key_type (str): Type of the key (e.g., ObjectType.AES or ObjectType.RSA).
            size (int): Key size (e.g., 256 for AES, 2048 for RSA).

        Returns:
            str: The key ID of the retrieved or newly created key.

        Logs:
            - Checks for existing keys.
            - Logs if the key is found or created.
        """
        Logger.log(f"Checking if key '{name}' exists.")
        keys = DSMClient.get_instance('sobjects').get_security_objects()
        for key in keys:
            if key.name == name:
                Logger.log(f"Key '{name}' found with ID: {key.kid}")
                return key.kid

        Logger.log(f"Creating new key: {name}")
        request = sdkms.v1.SobjectRequest(
            name=name, key_size=size, obj_type=key_type
        )
        key_id = DSMClient.get_instance('sobjects').generate_security_object(request).kid
        Logger.log(f"Key '{name}' created with ID: {key_id}")
        return key_id

    @staticmethod
    def encrypt(key_id, plaintext, object_type, mode=None, iv=None):
        """
        Encrypt Data
        ------------

        Encrypts plaintext using a specified cryptographic key stored in the DSM.

        Parameters:
            key_id (str): The ID of the key to use for encryption.
            plaintext (str): The data to encrypt.
            object_type (str): The type of encryption algorithm (e.g., ObjectType.AES).
            mode (str, optional): The encryption mode (e.g., CipherMode.CBC).
            iv (bytes, optional): The initialization vector (IV) for the encryption.

        Returns:
            sdkms.v1.EncryptResponse: The encryption result, including ciphertext and metadata.

        Logs:
            - Encryption start.
            - Encryption success with ciphertext details.
        """
        Logger.log(f"Encrypting the following plaintext: {plaintext}.")
        encrypt_request = sdkms.v1.EncryptRequest(
            alg=object_type, plain=bytearray(plaintext, 'utf-8'), mode=mode, iv=iv #iv is important for AES encryption
        )
        result = DSMClient.get_instance('crypto').encrypt(key_id, encrypt_request)
        Logger.log(f"Encryption successful. Ciphertext: {result.cipher}")
        return result

    @staticmethod
    def decrypt(key_id, ciphertext, object_type, mode=None, iv=None):
        """
        Decrypt Data
        ------------

        Decrypts ciphertext using a specified cryptographic key stored in the DSM.

        Parameters:
            key_id (str): The ID of the key to use for decryption.
            ciphertext (bytes): The encrypted data to decrypt.
            object_type (str): The type of encryption algorithm (e.g., ObjectType.AES).
            mode (str, optional): The decryption mode (e.g., CipherMode.CBC).
            iv (bytes, optional): The initialization vector (IV) used during encryption.

        Returns:
            str: The decrypted plaintext data.

        Logs:
            - Decryption start.
            - Decryption success with plaintext details.
        """
        Logger.log("Decrypting data.")
        decrypt_request = sdkms.v1.DecryptRequest(
            alg=object_type, cipher=ciphertext, mode=mode, iv=iv
        )
        result = DSMClient.get_instance('crypto').decrypt(key_id, decrypt_request)
        Logger.log(f"Decryption successful. Plaintext: {result.plain.decode('utf-8')}")
        return result.plain.decode('utf-8')

    @staticmethod
    def sign(key_id, message):
        """
        Sign Data
        ---------

        Generates a digital signature for the given message using a specified key.

        Parameters:
            key_id (str): The ID of the key to use for signing.
            message (str): The data to sign.

        Returns:
            bytes: The generated digital signature.

        Logs:
            - Signing start.
            - Signing success with signature details.
        """
        Logger.log("Signing data.")
        digest_request = sdkms.v1.DigestRequest(
            alg=DigestAlgorithm.SHA256, data=bytearray(message, 'utf-8')
        )
        digest = DSMClient.get_instance('digest').compute_digest(digest_request).digest

        sign_request = sdkms.v1.SignRequest(hash=digest, hash_alg=DigestAlgorithm.SHA256)
        result = DSMClient.get_instance('signverify').sign(key_id, sign_request)
        Logger.log(f"Signature generated: {result.signature}")
        return result.signature

    @staticmethod
    def verify(key_id, message, signature):
        """
        Verify a Signature
        ------------------

        Verifies the digital signature of a message using a specified key.

        Parameters:
            key_id (str): The ID of the key to use for verification.
            message (str): The original message.
            signature (bytes): The digital signature to verify.

        Returns:
            bool: True if the signature is valid; otherwise, False.

        Logs:
            - Verification start.
            - Verification result.
        """
        Logger.log("Verifying signature.")
        digest_request = sdkms.v1.DigestRequest(
            alg=DigestAlgorithm.SHA256, data=bytearray(message, 'utf-8')
        )
        digest = DSMClient.get_instance('digest').compute_digest(digest_request).digest

        verify_request = sdkms.v1.VerifyRequest(
            hash=digest, signature=signature, hash_alg=DigestAlgorithm.SHA256
        )
        result = DSMClient.get_instance('signverify').verify(key_id, verify_request)
        Logger.log(f"Signature verification result: {result.result}")
        return result.result

class CryptoManager_old:
    @staticmethod
    def create_or_retrieve_key(name, key_type, size):
        """Create or retrieve a key from DSM."""
        Logger.log(f"Checking if key '{name}' exists.")
        keys = DSMClient.get_instance('sobjects').get_security_objects()
        for key in keys:
            if key.name == name:
                Logger.log(f"Key '{name}' found with ID: {key.kid}")
                return key.kid
        
        Logger.log(f"Creating new key: {name}")
        request = sdkms.v1.SobjectRequest(
            name=name, key_size=size, obj_type=key_type
        )
        key_id = DSMClient.get_instance('sobjects').generate_security_object(request).kid
        Logger.log(f"Key '{name}' created with ID: {key_id}")
        return key_id

    @staticmethod
    def encrypt(key_id, plaintext, object_type, mode=None, iv=None):
        """Encrypt plaintext using DSM."""
        Logger.log("Encrypting data.")
        encrypt_request = sdkms.v1.EncryptRequest(
            alg=object_type, plain=bytearray(plaintext, 'utf-8'), mode=mode, iv=iv
        )
        result = DSMClient.get_instance('crypto').encrypt(key_id, encrypt_request)
        Logger.log(f"Encryption successful. Ciphertext: {result.cipher}")
        return result

    @staticmethod
    def decrypt(key_id, ciphertext, object_type, mode=None, iv=None):
        """Decrypt ciphertext using DSM."""
        Logger.log("Decrypting data.")
        decrypt_request = sdkms.v1.DecryptRequest(
            alg=object_type, cipher=ciphertext, mode=mode, iv=iv
        )
        result = DSMClient.get_instance('crypto').decrypt(key_id, decrypt_request)
        Logger.log(f"Decryption successful. Plaintext: {result.plain.decode('utf-8')}")
        return result.plain.decode('utf-8')

    @staticmethod
    def sign(key_id, message):
        """Sign a message using DSM."""
        Logger.log("Signing data.")
        digest_request = sdkms.v1.DigestRequest(
            alg=DigestAlgorithm.SHA256, data=bytearray(message, 'utf-8')
        )
        digest = DSMClient.get_instance('digest').compute_digest(digest_request).digest

        sign_request = sdkms.v1.SignRequest(hash=digest, hash_alg=DigestAlgorithm.SHA256)
        result = DSMClient.get_instance('signverify').sign(key_id, sign_request)
        Logger.log(f"Signature generated: {result.signature}")
        return result.signature

    @staticmethod
    def verify(key_id, message, signature):
        """Verify a signature using DSM."""
        Logger.log("Verifying signature.")
        digest_request = sdkms.v1.DigestRequest(
            alg=DigestAlgorithm.SHA256, data=bytearray(message, 'utf-8')
        )
        digest = DSMClient.get_instance('digest').compute_digest(digest_request).digest

        verify_request = sdkms.v1.VerifyRequest(
            hash=digest, signature=signature, hash_alg=DigestAlgorithm.SHA256
        )
        result = DSMClient.get_instance('signverify').verify(key_id, verify_request)
        Logger.log(f"Signature verification result: {result.result}")
        return result.result

# Workflows
class Workflows:
    @staticmethod
    def basic_aes_encryption(message):
        """
        Basic AES Encryption Workflow.
        
        This function demonstrates a simple AES encryption and decryption workflow:
        1. Retrieves or creates a shared AES key from the Fortanix DSM.
        2. Encrypts the provided plaintext message using the AES key in CBC mode.
        3. Decrypts the ciphertext using the same AES key and the generated IV.

        Parameters:
        - message (str): The plaintext message to be encrypted and decrypted.

        Workflow:
        1. Retrieve or create the AES key from DSM.
        2. Encrypt the plaintext message using AES in CBC mode.
        3. Decrypt the ciphertext back to plaintext using the same AES key and IV.

        Returns:
        - None: The function logs all the steps and results.
        """
        Logger.log("[Step 1] Starting Basic AES Encryption Workflow.", level="INFO")

        # Step 1: Retrieve or create the AES key
        Logger.log("[Step 2] Retrieving or creating the shared AES key.", level="INFO")
        aes_key = CryptoManager.create_or_retrieve_key("Shared AES Key", ObjectType.AES, 256)
        Logger.log(f"[Step 3] Shared AES Key ID: {aes_key}", level="INFO")

        # Step 2: Encrypt the message using AES in CBC mode
        Logger.log("[Step 1] Encrypting the plaintext message using AES in CBC mode.", level="INFO")
        encrypted_result = CryptoManager.encrypt(
            key_id=aes_key,
            plaintext=message,
            object_type=ObjectType.AES,
            mode=CipherMode.CBC
        )
        Logger.log(f"[Step 4] AES Encryption Result: Ciphertext: {encrypted_result.cipher}, IV: {encrypted_result.iv}", level="INFO")

        # Step 3: Decrypt the ciphertext using the AES key and IV
        Logger.log("[Step 5] Decrypting the ciphertext back to plaintext.", level="INFO")
        decrypt_result = CryptoManager.decrypt(
            key_id=aes_key,
            ciphertext=encrypted_result.cipher,
            object_type=ObjectType.AES,
            mode=CipherMode.CBC,
            iv=encrypted_result.iv
        )
        Logger.log(f"[Step 6] AES Decryption Result: Plaintext: {decrypt_result}", level="INFO")

        # Log completion of the workflow
        Logger.log("[Complete] Basic AES Encryption Workflow completed successfully.", level="INFO")
 
    @staticmethod
    def basic_rsa_workflow(message):
        """
        Basic RSA Encryption and Signature Workflow.

        This function demonstrates a complete RSA-based cryptographic workflow that includes:
        1. Key generation or retrieval for both sender and receiver.
        2. Encryption of a message using the receiver's public RSA key.
        3. Signing the original message using the sender's private RSA key.
        4. Decrypting the encrypted message using the receiver's private RSA key.
        5. Verifying the sender's signature using their public RSA key.

        Parameters:
            message (str): The plaintext message to be encrypted and signed.

        Returns:
            tuple:
                decrypted_data (str): The decrypted message after processing.
                signature_valid (bool): Boolean indicating if the signature verification succeeded.

        Steps:
        - Step 1: Initialize the workflow and log the process start.
        - Step 2: Generate or retrieve the sender's RSA key.
        - Step 3: Generate or retrieve the receiver's RSA key.
        - Step 4: Encrypt the plaintext message with the receiver's public key.
        - Step 5: Sign the original plaintext message with the sender's private key.
        - Step 6: Decrypt the ciphertext using the receiver's private key.
        - Step 7: Verify the signature using the sender's public key.
        """
        Logger.log("[Step 1] Starting basic RSA workflow.")

        # Create or retrieve sender's RSA key
        sender_rsa_key = CryptoManager.create_or_retrieve_key("John's RSA Key", ObjectType.RSA, 2048)
        Logger.log("[Step 2] Sender's RSA Key created or retrieved.")

        # Create or retrieve receiver's RSA key
        receiver_rsa_key = CryptoManager.create_or_retrieve_key("Priya's RSA Key", ObjectType.RSA, 2048)
        Logger.log("[Step 3] Receiver's RSA Key created or retrieved.")

        # Encrypt the message
        encrypted_result = CryptoManager.encrypt(receiver_rsa_key, message, ObjectType.RSA)
        Logger.log(f"[Step 4] RSA Encryption Result: Cipher={encrypted_result.cipher}")

        # Sign the message
        signed_data = CryptoManager.sign(sender_rsa_key, message)
        Logger.log(f"[Step 5] Signed Data: {signed_data}")

        # Decrypt the encrypted message
        decrypted_data = CryptoManager.decrypt(receiver_rsa_key, encrypted_result.cipher, ObjectType.RSA)
        Logger.log(f"[Step 6] Decrypted Data: {decrypted_data}")

        # Verify the signature
        signature_valid = CryptoManager.verify(sender_rsa_key, decrypted_data, signed_data)
        Logger.log(f"[Step 7] Signature Verification Result: {signature_valid}")

        return decrypted_data, signature_valid
 
    @staticmethod
    def aes_rsa_combined_workflow(sender_rsa_key, receiver_rsa_key, shared_aes_key, plaintext):
        """
        Combined AES and RSA Workflow.

        This function demonstrates a hybrid cryptographic workflow that combines AES and RSA for securing messages.
        It involves:
        1. Encrypting plaintext using AES for efficiency.
        2. Encrypting the AES key with the receiver's RSA public key for secure key exchange.
        3. Signing the plaintext with the sender's RSA private key for integrity verification.
        4. Decrypting the AES key with the receiver's RSA private key.
        5. Decrypting the ciphertext using the decrypted AES key.
        6. Verifying the signature using the sender's RSA public key.

        Parameters:
            sender_rsa_key (str): The sender's RSA key ID.
            receiver_rsa_key (str): The receiver's RSA key ID.
            shared_aes_key (str): The shared AES key ID.
            plaintext (str): The message to be secured.

        Returns:
            tuple:
                decrypted_message (str): The plaintext after decryption.
                signature_valid (bool): Boolean indicating if the signature verification succeeded.

        Steps:
        - Step 1: Encrypt the plaintext using AES.
        - Step 2: Encrypt the AES key with the receiver's RSA public key.
        - Step 3: Sign the plaintext using the sender's RSA private key.
        - Step 4: Decrypt the AES key with the receiver's RSA private key.
        - Step 5: Decrypt the ciphertext using the decrypted AES key.
        - Step 6: Verify the signature using the sender's RSA public key.
        """
        Logger.log("[Step 1] Starting AES-RSA combined workflow.")

        # Encrypt plaintext using AES
        aes_encryption_result = CryptoManager.encrypt(
            key_id=shared_aes_key,
            plaintext=plaintext,
            object_type=ObjectType.AES,
            mode=CipherMode.CBC
        )
        Logger.log(f"[Step 2] AES Encryption Result: Cipher={aes_encryption_result.cipher}, IV={aes_encryption_result.iv}")

        # Encrypt AES key using RSA
        encrypted_aes_key_result = CryptoManager.encrypt(
            key_id=receiver_rsa_key,
            plaintext=aes_encryption_result.kid,
            object_type=ObjectType.RSA
        )
        Logger.log(f"[Step 3] Encrypted AES Key Result: Cipher={encrypted_aes_key_result.cipher}")

        # Sign plaintext using RSA
        signed_data = CryptoManager.sign(sender_rsa_key, plaintext)
        Logger.log(f"[Step 4] Generated Signature: {signed_data}")

        # Decrypt AES key with Receiver RSA Private Key
        decrypted_aes_key = CryptoManager.decrypt(
            receiver_rsa_key,
            encrypted_aes_key_result.cipher,
            ObjectType.RSA
        )
        Logger.log(f"[Step 5] Decrypted AES Key: {decrypted_aes_key}")

        # Decrypt cipher with AES key
        decrypted_message = CryptoManager.decrypt(
            decrypted_aes_key,
            aes_encryption_result.cipher,
            ObjectType.AES,
            CipherMode.CBC,
            aes_encryption_result.iv
        )
        Logger.log(f"[Step 6] Decrypted Message: {decrypted_message}")

        # Verify signature
        signature_valid = CryptoManager.verify(
            sender_rsa_key,
            decrypted_message,
            signed_data
        )
        Logger.log(f"[Step 7] Signature Verification Result: {signature_valid}")

        Logger.log("[Step 8] Ending AES-RSA combined workflow.")

        return decrypted_message, signature_valid

# Main Function
def main():
    try:
        """Entry point for the script."""
        DSMClient.initialize()
        # Parse workflow type
        workflow = cl_args.workflow.lower()
        message = cl_args.message.lower()

        if workflow == "aes":
            Logger.log("Executing AES Workflow.")      
            Workflows.basic_aes_encryption(message)
        elif workflow == "rsa":
            Logger.log("Executing RSA Workflow.")
            Workflows.basic_rsa_workflow(message)
        elif workflow == "combined":
            Logger.log("Executing Advanced AES-RSA Combined Workflow.")
            sender_rsa_key = CryptoManager.create_or_retrieve_key("John's RSA Key", ObjectType.RSA, 2048)
            receiver_rsa_key = CryptoManager.create_or_retrieve_key("Priya's RSA Key", ObjectType.RSA, 2048)
            shared_aes_key = CryptoManager.create_or_retrieve_key("Shared AES Key", ObjectType.AES, 256)
            Workflows.aes_rsa_combined_workflow(sender_rsa_key, receiver_rsa_key, shared_aes_key, message)
        else:
            Logger.log(f"Invalid workflow type: {workflow}. Please choose 'aes', 'rsa', or 'combined'.", level="ERROR")
    except Exception as e:
            Logger.log(f"An error occurred: {e}", level="ERROR")
    finally:
        Logger.log("Script execution completed.")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Secure Communication Using Fortanix DSM")
    parser.add_argument('--api-key', required=True, help='Base64-encoded API key for DSM access')
    parser.add_argument('--api-endpoint', default=DEFAULT_API_ENDPOINT, help='Fortanix DSM API endpoint')
    parser.add_argument('--workflow', default="rsa", help="Workflow to execute: aes, rsa, combined (default: rsa)")
    parser.add_argument('--message', default="Hello Priya!", help="Plaintext message to encrypt. Default 'Hello Priya'")
    parser.add_argument('--no-verify-ssl', action='store_false', dest='verify_ssl', help='Disable SSL verification')
    global cl_args
    cl_args = parser.parse_args()

    main()
